<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.35">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>如何阅读ECMAScript | 前端之旅</title><meta name="description" content="博客">
    <link rel="modulepreload" href="/blog/assets/app.3c7f3972.js"><link rel="modulepreload" href="/blog/assets/How-To-Read-ECMAScript-spec.html.d6c82f10.js"><link rel="modulepreload" href="/blog/assets/How-To-Read-ECMAScript-spec.html.ac5434d7.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/blog/assets/style.7e38007d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><!----><span class="site-name">前端之旅</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/workkk98" rel="noopener noreferrer" target="_blank" aria-label="Github主页"><!--[--><!--]--> Github主页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/workkk98" rel="noopener noreferrer" target="_blank" aria-label="Github主页"><!--[--><!--]--> Github主页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/blog/guide/" class="sidebar-item sidebar-heading" aria-label="介绍"><!--[--><!--]--> 介绍 <!--[--><!--]--></a><!----></li><li><a href="/blog/npm/" class="sidebar-item sidebar-heading" aria-label="npm"><!--[--><!--]--> npm <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/npm/npm-scripts" class="sidebar-item" aria-label="npm-scripts"><!--[--><!--]--> npm-scripts <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/blog/vue/" class="sidebar-item sidebar-heading" aria-label="vue"><!--[--><!--]--> vue <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/vue/renderwatcher" class="sidebar-item" aria-label="渲染观察者"><!--[--><!--]--> 渲染观察者 <!--[--><!--]--></a><!----></li><li><a href="/blog/vue/VNode_DOM" class="sidebar-item" aria-label="从VNode到DOM"><!--[--><!--]--> 从VNode到DOM <!--[--><!--]--></a><!----></li><li><a href="/blog/vue/createComponent" class="sidebar-item" aria-label="创建子组件"><!--[--><!--]--> 创建子组件 <!--[--><!--]--></a><!----></li><li><a href="/blog/vue/vue-hot-reload-api" class="sidebar-item" aria-label="vue-loader是如何支持热更新的"><!--[--><!--]--> vue-loader是如何支持热更新的 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/blog/others/" class="router-link-active sidebar-item sidebar-heading active" aria-label="随笔"><!--[--><!--]--> 随笔 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/others/github-actions" class="sidebar-item" aria-label="github actions"><!--[--><!--]--> github actions <!--[--><!--]--></a><!----></li><li><a href="/blog/others/How-To-Read-ECMAScript-spec" class="router-link-active sidebar-item active" aria-label="如何阅读ECMAScript规范"><!--[--><!--]--> 如何阅读ECMAScript规范 <!--[--><!--]--></a><!----></li><li><a href="/blog/others/nginx" class="sidebar-item" aria-label="nginx使用手册"><!--[--><!--]--> nginx使用手册 <!--[--><!--]--></a><!----></li><li><a href="/blog/others/abstract-comparison" class="sidebar-item" aria-label="从ECMAScript规范来看相等操作符"><!--[--><!--]--> 从ECMAScript规范来看相等操作符 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/blog/functional-programming/" class="sidebar-item sidebar-heading" aria-label="函数式编程"><!--[--><!--]--> 函数式编程 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/functional-programming/chapter-1" class="sidebar-item" aria-label="第一章"><!--[--><!--]--> 第一章 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/blog/TypeScript/" class="sidebar-item sidebar-heading" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/TypeScript/start" class="sidebar-item" aria-label="体操入门"><!--[--><!--]--> 体操入门 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="如何阅读ecmascript" tabindex="-1"><a class="header-anchor" href="#如何阅读ecmascript" aria-hidden="true">#</a> 如何阅读ECMAScript</h1><h3 id="language-type-语言类型-和-specification-type-规范类型" tabindex="-1"><a class="header-anchor" href="#language-type-语言类型-和-specification-type-规范类型" aria-hidden="true">#</a> Language Type（语言类型）和 Specification Type（规范类型）</h3><blockquote><p>ECMASScript规范内部会创建一些类似于对象的东西来按照特性形式存储数据。</p><p>而规范类型就是指<strong>仅限于规范文档内部使用的一些数据类型</strong>，我们创造这种数据类型的目的将同种类的数据结构抽象起来，便于复用。比较重要的规范类型有：List、Record、Completion Record、Reference、Property Descriptor、Environment Record 等。</p></blockquote><ul><li><p>List列表</p><p>JS 中函数的参数 arguments，实际上在规范内部就是借助 <a href="https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23sec-list-and-record-specification-type" target="_blank" rel="noopener noreferrer">List<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 这一规范类型来创建的。类似的，JS 中的 Set、Map 这样的有序结构本质上也依赖 List 来保证它内容的有序性。</p><p>在规范当中，List 有它自己的一个字面量写法，形如 <code>« 1, 2 »</code>，它表示一个 List，它的第一位值是 <code>1</code>、第二位值是 <code>2</code>。</p></li><li><p>record记录</p><p><a href="https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23sec-list-and-record-specification-type" target="_blank" rel="noopener noreferrer">Record<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 规范类型其实就类似于 Object 这种语言类型，它像对象的属性那样，具有若干 named fields（命名字段），这个 field 名称必须用两组方括号括起来。我们可以使用 <code>{ [[Field1]]: 42, [[Field2]]: false, [[Field3]]: empty }</code> 这样的字面量写法来表达一个 Record。而在访问的时候，用的是 <code>R.[[Field2]]</code> 这样的形式，它是意思是访问 <code>R</code> 这个 Record 的 <code>[[Field2]]</code> field。<strong>Record 的 field 是无序的，而且它不像 JS 对象那样有原型继承，对于一个 Record 来说，它只能带有明确列出来的 field。</strong></p><p>请注意，这种 <code>[[ ]]</code> 双方括号写法可不是 Record field 的专利，规范中，<strong>Internal Method（内部方法）</strong> 和 <strong>Internal Slot（内部槽）</strong> 也是用双方括号括起来的，它们的区别之后会讲到。</p></li></ul><p>​</p><h3 id="internal-method-内部方法-和-internal-slot-内部槽" tabindex="-1"><a class="header-anchor" href="#internal-method-内部方法-和-internal-slot-内部槽" aria-hidden="true">#</a> Internal Method（内部方法）和 Internal Slot（内部槽）</h3><p>我们知道编程语言中对象有属性和方法，在 ES 规范的内部，对象拥有一系列的 <a href="https://link.zhihu.com/?target=https%3A//ecma262.docschina.org/%23sec-object-internal-methods-and-internal-slots" target="_blank" rel="noopener noreferrer">Internal Method（内部方法）和 Internal Slot（内部槽）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p><strong>Internal Method（内部方法）<strong>是规范用来定义对象自身的行为逻辑的一种算法。比如我们要读取 o 对象的 p 属性，我们写 JS 代码的话会是 <code>o.p</code> 或者 <code>o[&quot;p&quot;]</code>，无论是写哪种代码来读取，这个代码的</strong>语义（semantic）<strong>是一样的，因此它会执行这个语义所对应的 Internal Method。比如读取对象属性的 Internal Method 叫做 [[Get]]，它接受的参数是 propertyKey 和 Receiver。调用 [[Get]] 就像调用一个方法，用括号来表示调用，然后括号中写参数，所以它内部的执行的就是 <code>o.[[Get]](p, o)</code>。这里它的</strong>语义</strong>就是「读取 o 对象的 p 属性」。</p><p>（Receiver 在我们写 JS 的 Proxy 时也会接触到，如果你对 Receiver 感到疑惑，没关系，本系列的后续文章（也许）会讲到这个知识点，此处我们先跳过。）</p><p>Record 的 field 和 Internal Method、Internal Slot 都是使用双方括号，那应该怎么区分呢？区分方式就是看它的语境：如果前面是 Record，那么后面跟的 [[xxx]] 就是这个 Record 的 field；<strong>如果前面是对象，比如 <code>O.[[xxx]]()</code> ，由于使用了括号去执行，因此它是 Internal Method；如果只是单纯 <code>O.[[xxx]]</code> 那就是 Internal Slot。</strong></p><p>Internal Method（内部方法）执行的返回值是 Completion Record（完成记录），这个后面会讲。</p><p>**Internal Slot（内部槽）**用于在对象上记录状态、数据。</p><p>Internal Method 和 Internal Slot 都是 ES 规范内部的概念，因为我们不能通过 JS 来访问、调用它们。对于 JS 语言实现来说，规范也不要求具体实现的逻辑、步骤、算法和规范的 Internal Method 一模一样，它仅要求实现表现出来的特性、结果和规范一致即可。</p><p>规范还给对象、函数定义了一套所谓的 <strong>Essential Internal Methods（基本内部方法）</strong>。</p><h3 id="essential-internal-methods-基本内部方法" tabindex="-1"><a class="header-anchor" href="#essential-internal-methods-基本内部方法" aria-hidden="true">#</a> Essential Internal Methods（基本内部方法）</h3><p><a href="https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23table-essential-internal-methods" target="_blank" rel="noopener noreferrer">Essential Internal Methods（基本内部方法）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 是 ES 规范给对象定义的一系列最基本的、必不可少的内部方法，它决定了对象的基本的、默认的行为逻辑。</p><p>规范中规定，当一个对象拥有 [[Call]] 内部方法时，就可以称之为是 function object（函数对象）。当一个函数对象拥有 [[Construct]] 内部方法时，就可以称之为 constructor（构造器）。也就是说，构造器是一种特殊的函数，而函数是一种特殊的对象。函数对象和构造器具有额外的 <a href="https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23table-additional-essential-internal-methods-of-function-objects" target="_blank" rel="noopener noreferrer">基本内部方法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p>如果一个对象（包含函数对象和构造器）的所拥有的基本内部方法的表现行为和 <a href="https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23sec-ordinary-object-internal-methods-and-internal-slots" target="_blank" rel="noopener noreferrer">9 Ordinary and Exotic Objects Behaviours<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 所定义的完全相同，就意味着这样的对象是 <strong>ordinary object 常规对象</strong>。</p><p>如果一个对象的表现行为和以上述定义有所不同（哪怕只是有一处差异），就意味着它是 <strong>exotic object 异质对象</strong>。</p><blockquote><p>请注意，不是说 exotic object 它不具备 Essential Internal Methods。Essential Internal Methods 是每个对象都会必备的，只是 exotic object 带有特殊的内部方法，它覆盖了默认的 Essential Internal Methods 而已。</p></blockquote><h3 id="completion-record完成记录" tabindex="-1"><a class="header-anchor" href="#completion-record完成记录" aria-hidden="true">#</a> completion record完成记录</h3><p><a href="https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23sec-completion-record-specification-type" target="_blank" rel="noopener noreferrer">Completion Record<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 是一种特殊的 Record，用于表述流程运行到特定步骤时的运行结果，<strong>ES 规范中可任何运行的步骤、语句都会显式或隐式地返回一个 Completion Record</strong>，它具有特定的三个 field，如下图所示。</p><p><img src="/blog/assets/complete-record.fd71da23.png" alt="complete-record"></p><p>当 Completion Record 的 <code>[[Type]]</code> 是 normal 时，我们就成这个 Completion Record 是 <strong>normal completion 正常完成</strong>，否则，就称之为 <strong>abrupt completion 中断式完成</strong>。</p><p>访问 Completion Record 的值，或者说从 Completion Record 中取值，等效于是读取 Completion Record 中名叫 <code>[[Value]]</code> 的这个 field 的值。当然前提是这个 Completion Record 不能是 abrupt completion。</p><p>搞这种 Completion Record 的好处是什么呢？**因为规范中涉及太多操作逻辑的调用，必须设计出一种良好的异常处理机制，使得规范文档能够简洁明确地处理异常。**我们知道，如果在写代码时嵌套了很多层 try-catch 结构，那么代码的可读性会非常差，外部感知不到内部出了什么错，因为内部的异常可能被 catch 掉了。ES 规范也会遇到相同的问题，尤其是 ES 所描述的流程是一种规范层面的抽象流程，它不是实际的程序代码，因此它必须即时的处理异常，而不能「生吞」它。</p><p>有了 Completion Record 这种规范类型之后，它不仅携带了运行结果（[[Value]]），它可以兼容错误情况，如果当前步骤遇到错误的时候（也就是 abrupt completion 的时候）就可以直接显式地处理它，也可以让错误一层一层向外冒泡，并且如果是 break 或者 continue 的话，那也能自说明地表达出接下来的运行位置。</p><p>这样一来我们就省略掉 try-catch 语句，所以这就是 ES 规范使用 Completion Record 来处理错误的原因。当然这是规范内部定义的一种概念，不代表在实现的时候也要照搬这一套。</p><p>接下来简单演示一下 Completion Record 使用，思路是一个固定套路的三板斧，假设我们有一个叫做 <code>doAbstractOperation</code> 的操作步骤：</p><ol><li>令 <code>completionRecordResult</code> 为 <code>doAbstractOperation()</code> 的结果。</li><li>如果 <code>completionRecordResult</code> 是 abrupt completion，则直接返回 <code>completionRecordResult</code>。</li><li>读取 <code>completionRecordResult.[[Value]]</code> 的值，赋值给 <code>result</code>。</li></ol><p>这样一来我们就能安全地获取结果 <code>result</code>，而且我们能够保证，只要我们拿到了 <code>result</code>，它就一定是正常值，因为如果遇到错误的话，在它之前就会直接退出。可能有些思维缜密的人会问，那么如果第三步出错咋办？如果 <code>completionRecordResult</code> 不含 <code>[[Value]]</code> 呢？实际上，它一定会含有 <code>[[Value]]</code>。因为 Completion Record 可以在规范的操作中<strong>隐式返回</strong>，它实际上确保了返回值一定包装在一个 Completion Record 结果中。由于我们第二步就扔出了 abrupt completion，所以根据定义，所有能够走到第三步的 Completion Record 都是 normal completion，都有具有 <code>[[Value]]</code>，因此这个访问过程是安全的。</p><p>当然，如果我们真的去这么使用 Completion Record 的话也会很麻烦，这意味每一次获取一个 Completion Record，都要做判断，都要写这三行逻辑，如果是 abrupt completion 就直接返回它，若是 normal completion 就取出其中的 <code>[[Value]]</code>。遇到重复的操作步骤，我们显然应该将其提炼成一个共通步骤，然后引用它即可。这就形成了我接下来要讲的 <code>ReturnIfAbrupt</code>。</p><h3 id="returnabrupt" tabindex="-1"><a class="header-anchor" href="#returnabrupt" aria-hidden="true">#</a> returnAbrupt</h3><p>有了之前的基础，ReturnIfAbrupt 就非常好理解了。它是一种为了<strong>简化规范的算法步骤而发明的的简写方式</strong>。ReturnIfAbrupt(completionRecordResult) 就是我们刚才说的，在遇到 Completion Record 时，「如果是 abrupt completion 就直接返回它，若是 normal completion 就取出其中的 <code>[[Value]]」</code>。由于执行抽象操作会生成 Completion Record，因此也就相当于是 ReturnIfAbrupt(doAbstractOperation())。</p><p>不过请千万注意一点，<strong>绝对不能将 ReturnIfAbrupt 当作一个函数来理解</strong>，因为它在执行 return 时，不是从 ReturnIfAbrupt 的结构体内部 return 出来（它压根就没有结构体）（这里我觉得意思就是说没有在函数栈上加上这个ReturnIfAbrupt函数，就是在原地返回的），而是在 ReturnIfAbrupt 所在的位置原地 return 到当前步骤的外部。因此它的特性不像函数，更类似于是一种 C 语言的宏（可运行的字符串）。</p><p>有了 ReturnIfAbrupt 这个简写之后，原本我举的例子 doAbstractOperation 要用三行才表述出来的逻辑被压缩成一个简短的 ReturnIfAbrupt(doAbstractOperation())。</p><p>然而，在实际规范中，ReturnIfAbrupt 出现的频率不那么高，因为我们有一套更加优秀的简写，问号简写标记「?」和叹号简写标记「!」。</p><h3 id="问号简写标记「-」和叹号简写标记「-」" tabindex="-1"><a class="header-anchor" href="#问号简写标记「-」和叹号简写标记「-」" aria-hidden="true">#</a> 问号简写标记「?」和叹号简写标记「!」</h3><p>问号简写标记「?」 是一个前缀符号，它后面跟着一个空格，然后跟着操作名称。比如 ? doAbstractOperation()，它完全等价于 <code>ReturnIfAbrupt(doAbstractOperation())</code>，它表示如果这个操作结果是 abrupt completion，则在 ? doAbstractOperation() 这个位置原地把 abrupt completion 给 return 出去；如果操作结果是 normal completion，则提取它内部的 <code>[[Value]]</code> 出来，作为整个 ? doAbstractOperation() 结果。</p><p>叹号简写标记「!」和「?」有点类似，唯一的区别在于<strong>它是一个隐式断言assert</strong>，它断言此处执行的逻辑永远不会出现 abrupt completion，永远只会拿到 normal completion。! doAbstractOperation() 的结果就是这个 normal completion 的 <code>[[Value]]</code>。</p><p>OK，理解了的用法后，我们结合规范来看一看。还记得我们上文讲到的规范中抽象操作 Number.prototype.toString 吗？它在第一步 1. Let x be ? thisNumberValue(this value). 中使用了问号简写标记「?」和抽象操作 thisNumberValue，它用问号标记的原因在于 thisNumberValue 确实有可能会抛出一个异常。</p><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/262265857" target="_blank" rel="noopener noreferrer">ECMAScript阅读指南（二）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.3c7f3972.js" defer></script>
  </body>
</html>
